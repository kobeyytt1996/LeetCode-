# 力扣(LeetCode)刷题总结
1. 数组
   1. 遍历：题14 最长公共前缀（简单。但解法多，可扩展思路，相互对比，如纵向比较，分治法，排序后比头尾）、题31. 下一个排列（关键在于分析题目，用例子模拟一遍找到规律）、题42. 接雨水（以每个元素能接多少水来看问题，关键在于对空间复杂度的优化，**不要死板的想遍历就是从坐到右，本题的特殊情况可以双指针遍历**）、题57. 插入区间（官解是直接遍历，拷贝和合并区间同时完成。我的想法是先二分查找到插入点，再拷贝前面的，合并当前，拷贝后面的，思路有点绕且复杂度无显著提升，优先选择官方的更不易错的写法）、题66. 加一、题68. 文本左右对齐（关键在准确理解题意，并考虑好各种情况）
   2. 排序：题15 三数之和（易错点在于去除重复。关键部分还是写对快排）、题56. 合并区间（vector本身有重载operator<，不用提供functor）、
   3. 二分查找：题33 搜索旋转排序数组（还是要找到局部有序数组，才能更好的进行二分查找，也简化了问题）、题34和题35（类似，都是排序数组中找到第一个大于target的索引）、
   4. 双指针：
      1. 快慢：题26 删除有序数组中的重复项、题27 移除元素
      2. 左右：题75. 颜色分类（*难点在于如何只遍历一次，是对partition算法的一种扩展）
   5. 回溯法：题39，40. 组合总和（*回溯法：两点思考：1.要简化回溯时每一步做的事，不易出错，这里即选这个数或不选 2. 常和回溯搭配的是剪枝，这里可以考虑把数组先排个序，遇到大于target的数，就不用往后遍历了，不一定更快，但是要有这种思路；在40题里，注意和39题有很关键的不同点，要注意处理，但整体思路一样，且使得排序成为必备条件）、题46，**47**. 全排列（\* 最典型的回溯法。但47里有两种解法。一种是用set确保每一位上不用重复的数字，但因此会带来内存上极大开销。第二种看官方题解，对数组先排序，再用一个数组记录每个数字是否被加上了，牺牲了一点时间效率换取了空间效率。**回溯法算复杂度通常先看dfs执行次数，再看一次dfs的复杂度**） 
   6. 辅助数据结构：题41. 缺失的第一个正数（原地哈希，常见的数组当作哈希表问题，细心）、题49. 字母异位词分组（判断相同元素直接想到hashMap，关键在于不同的key和hash functor带来的效率差距。自己尝试重写了hash，但效果不好，最好尝试用STL提供的版本，官方解答的两种方法效率更高。**复杂度较高的问题，做排序通常能优化。**）、题71.简化路径
   7. 贪心：题45，. 跳跃游戏 II、
   
2. 二维数组：

   1. 辅助数据结构：题36. 有效的数独（判重就想set，数字范围小则用数组代替，甚至可以尝试用bitset）
   2. 回溯法：**题37. 解数独**（和题36相似，但这里回溯是核心。还涉及贪心，考虑数独的玩法，从最少可能数值的坐标开始回溯，每次都找有最少可能数值，大大提高效率。不用写代码了，了解思路即可）
   3. 特殊技巧：**48. 旋转图像**（**两种复杂度相同的做法：1. 直观的想法，一圈一圈向里遍历，确定每个点的交换位置，然后做3次swap，关键在于找到坐标，写出坐标，（看高赞的评论）更容易找到规律。2.看官方题解，矩阵旋转可以是上下翻转和对角线翻转的结果。这道题不要想着严谨的数学推导，要靠一点直觉）
   4. 遍历：题73. 矩阵置零（易错。要先想清楚边界情况。第一行和第一列是特殊情况，需要专门的数字来标记）
   5. 二分查找：题74. 搜索二维矩阵（官解有两种做法，只需能写出第一种。因为两种方法复杂度相当，且第一种不易错，并能出来每行元素个数不相同的情况）
   6. 滑动窗口：题76. 最小覆盖子串（自己的思路是对的。但关键在于简化写法，忽略一些细节，能在更短时间内写完，且不损失过多复杂度，可参见该[答案](https://leetcode-cn.com/problems/minimum-window-substring/solution/leetcode-76-zui-xiao-fu-gai-zi-chuan-cja-lmqz/)）

3. 字符串

   1. 递归：题17 电话号码的字母组合（全排列，就想递归。也可以用队列，虽然时空复杂度没区别，但是个很好的思路）
   2. 辅助数据结构：题20. 有效的括号（栈。简单题可以适当想想剪枝，比如字符总数为奇数，则直接false）、**题30. 串联所有单词的子串**（*判断是否出现，第一反应就是Map，以单词为单位，复杂题可适当用库函数，还要牢牢记清题目条件）

   3. 遍历：

   ​              1. 遍历（特殊题）：**题5 最长回文子串**（1. 中心扩散 2. *Manacher算法。时间复杂度降到O(n)，不要求具体写，但思想要了解，主旨即只遍历一次，尽可能用遍历过的结果帮后面判断）、**题28 实现 strStr()**（**字符串匹配：1. KMP算法：时间复杂度：O(m+n)，理解前缀后缀，利用已经算过的简化后面的计算，使得只遍历一次，然后重要的是如何构建next数组：本质又是字符串匹配，用前缀匹配后缀。（高赞答案都讲的不清晰，试着自己按照上述理解）2.Sunday算法：了解即可，比KMP时间复杂度差很多，为O(mn)）、题65. 有效数字（最直接不易错的方式为遍历并分情况讨论。[官解](https://leetcode-cn.com/problems/valid-number/solution/you-xiao-shu-zi-by-leetcode-solution-298l/)使用了确定有限状态自动机，了解其用法即可，写法复杂且本质是暴力枚举）、题67. 二进制求和（遍历加翻转最直观）

   4. 动态规划：**题32 最长有效括号**（**1. 动归，最长子串题常常用到。2. 栈，括号题常用。但这里相对复杂难处理 3. 贪心，太精妙了，左右各一遍堪称牛逼，比前两种省了空间复杂度）

4. 双字符串或数组：

      1. 遍历：**题43. 字符串相乘**（*摆脱计算乘法的传统思维，把思维简化，只专注于两个位上的数字相乘，就可以把计算部分用int的乘法代替，好写很多）
      2. 动归（通常状态转移方程是二维）：**题10和44 字符串匹配**（**1.剑指offer上用递归，但因产生重复子问题，是超时的，尤其在题44. 2.动态规划。此题的首选解法。且解法有细节，如||的使用，可看官方题解）、题64. 最小路径和（用动归的前提即无后效性）、题72. 编辑距离（有多种情况的复杂问题第一想法就是动态规划。关键在确定转移方程，其和状态转移时的选择方式是密切相关的）

5. 链表：

   1. 单链表：
      1. 双指针：题19 删除链表的倒数第 N 个结点、
      2. 排序：题23 合并K个升序链表（1.归并排序，注意和数组的不同，这里优先迭代；2. 小顶堆）
      3. 遍历：题61. 旋转链表（简单题一定要一次做对）
      4. 遍历多指针节点交换：题24 两两交换链表中的节点（注意边界情况）、题25 K 个一组翻转链表（易错，细节，在这种翻转等改变链表结构操作的时候，每当使用一个节点以及其next的时候，一定想清楚它还是不是你本意想用的）

6. 数字：
   1. 回溯法（递归）：
      1. 题22. 括号生成（1. 回溯法，即DFS，要同时想到栈和BFS，但通常递归写BFS是首选，其他两种方式在这里需要自定义数据结构来记录递归中的参数，故不推荐 2. 动态规划，思路可谓非常惊艳，但空间复杂度不好确定，作为思路拓展）、题51、52. N 皇后（给出所有解法就想到回溯法，自己画画图就能找到遍历过程，关键在于对对角线的处理，既可以往回遍历所有皇后判断是否在同一对角线，也可以向最高赞解那样利用数组记录。52是一样的。两题在记录数组上可以考虑用数字或bitset代替数组或set）、 题60. 排列序列（回溯如果不需要取得所有情况，而是第几个情况，通常可以用数学的方式算的）
   2. 二分查找：
      1. **题29. 两数相除**（**二分查找，类似第50题求幂，本质上是利用答案的数字本质上可以写成二进制，此题看[官方题解](https://leetcode-cn.com/problems/divide-two-integers/solution/liang-shu-xiang-chu-by-leetcode-solution-5hic/)的第二解法即可，另一方面各种防止溢出的细节也要注意）、题50. Pow(x, n)（二分查找的典型。但千万别轻视，细致的考察各种情况。既可以从最低位的1往前，也可以从最高位的1往后。）、题69. Sqrt(x)（官解提供了三种解法。会用二分查找即可。注意为了防止数字溢出，可以用除法代替乘法）
   3. 动归：
      1. 题38. 外观数列（思路简单，但可以考虑用move来提升性能。中间算相等元素区间的时候，一般双指针最清晰）、2、62、63. 不同路径（动归。这种很有规律的题通常有数学公式的快速解法，这题就可以用组合，面试时即便想不出来具体解法，也要表述出记得向该方向探究）
   4. 遍历：
      1. 题59. 螺旋矩阵 II（还是按照上下左右四个边界进行迭代）