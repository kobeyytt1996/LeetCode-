# 力扣(LeetCode)刷题总结
1. 数组
   1. 遍历（这类题通常把握了题目中的特殊条件限定）：题14 最长公共前缀（简单。但解法多，可扩展思路，相互对比，如纵向比较，分治法，排序后比头尾）、题31. 下一个排列（关键在于分析题目，用例子模拟一遍找到规律）、题42. 接雨水（以每个元素能接多少水来看问题，关键在于对空间复杂度的优化，**不要死板的想遍历就是从坐到右，本题的特殊情况可以双指针遍历**）、题57. 插入区间（官解是直接遍历，拷贝和合并区间同时完成。我的想法是先二分查找到插入点，再拷贝前面的，合并当前，拷贝后面的，思路有点绕且复杂度无显著提升，优先选择官方的更不易错的写法）、题66. 加一、题68. 文本左右对齐（关键在准确理解题意，并考虑好各种情况）、**题134. 加油站**（[利用了题目特点](https://leetcode-cn.com/problems/gas-station/solution/shi-yong-tu-de-si-xiang-fen-xi-gai-wen-ti-by-cyayc/)，找到最低点，下一个就是出发点）、题135. 分发糖果（将后一个数和前一个数的关系分为大于小于和等于分别处理即可，时刻记住最小糖果的思想）、题137. 只出现一次的数字 II（按有限状态自动机简单理解即可）、题169. 多数元素（投票算法，相同为赞同票，不相同为反对票，票数为0的时候要换届）
   2. 排序：题15 三数之和（易错点在于去除重复。关键部分还是写对快排）、题56. 合并区间（vector本身有重载operator<，不用提供functor）、**题164. 最大间距**（根据题目要求，线性时间的排序就想基数排序和桶排序，因桶排序并不真的需要完成排序，只用得到每个桶的最大最小值，因此表现更好一些。注意实际中logn的值也不会太大，因此快排完成复杂度也能接受。）、题179. 最大数（了解证明逻辑即可。注意边界情况，如大数，数组里都是0等）
   3. 二分查找：题33、**81** 搜索旋转排序数组（还是要找到局部有序数组，才能更好的进行二分查找，也简化了问题）（\*81看官解即可，情况较复杂，但基本思路仍不变，要画图并写出比较关系，来简化比较的次数）、题34和题35（类似，都是排序数组中找到第一个大于target的索引）、题153、154. 寻找旋转排序数组中的最小值、题162. 寻找峰值（看logn就想二分，关键条件是相邻值一定不相等，[借用相邻值即可判断](https://leetcode-cn.com/problems/find-peak-element/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-qva7v/)）
   4. 双指针：
      1. 快慢：题26、80 删除有序数组中的重复项（80题注意扩展性，写的解法应能处理最多出现n次的情况）、题27 移除元素
      2. 左右：题75. 颜色分类（*难点在于如何只遍历一次，是对partition算法的一种扩展）
      2. 其他：163. 缺失的区间（处理区间，就想到双指针法）、题170. 两数之和 III - 数据结构设计（数组和哈希表均可。重点看数组，要询问使用场景是find调用多还是add，来决定在哪个接口里排序）
   5. 回溯法：题39，40. 组合总和（*回溯法：两点思考：1.要简化回溯时每一步做的事，不易出错，这里即选这个数或不选 2. 常和回溯搭配的是剪枝，这里可以考虑把数组先排个序，遇到大于target的数，就不用往后遍历了，不一定更快，但是要有这种思路；在40题里，注意和39题有很关键的不同点，要注意处理，但整体思路一样，且使得排序成为必备条件）、题46，**47**. 全排列（\* 最典型的回溯法。但47里有两种解法。一种是用set确保每一位上不用重复的数字，但因此会带来内存上极大开销。第二种看官方题解，对数组先排序，再用一个数组记录每个数字是否被加上了，牺牲了一点时间效率换取了空间效率。**回溯法算复杂度一种方法是先看dfs执行次数，再看一次dfs的复杂度**） 、**题78、90. 子集**（1.回溯法 **2. 位运算。**每个元素选或者不选，即可用数字的每一位0和1组合代表一种可能。因此可用迭代来完成这题。90题同理，但需要先排序）
   6. 动态规划：题121-123. **买卖股票**的最佳时机（有一系列相关问题，动态规划的经典系列，看最高赞即可）、题152. 乘积最大子数组（动归。**关键在于简化写法，如果按符号考虑，需要考虑多种情况。因此用最大最小来记录**）、题188. 买卖股票的最佳时机 IV（同题121-123，同一思路解决即可。注意k超过数组一半无意义，限定k的上限。还有一种不需要空间复杂度解法，看最高赞略读即可）、题198. 打家劫舍
   7. 辅助数据结构：题41. 缺失的第一个正数（原地哈希，常见的数组当作哈希表问题，细心）、题49. 字母异位词分组（判断相同元素直接想到hashMap，关键在于不同的key和hash functor带来的效率差距。自己尝试重写了hash，但效果不好，最好尝试用STL提供的版本，官方解答的两种方法效率更高。**复杂度较高的问题，做排序通常能优化。**）、题71.简化路径、题84. 柱状图中最大的矩形（单调栈。核心在于找到一个元素对应的两边比它小的元素）、题**128. 最长连续序列**（不要想着一下子找到O(n)的解法，要一步一步优化）、**题149. 直线上最多的点数**（关键还是题意的理解。[重要技巧](https://leetcode-cn.com/problems/max-points-on-a-line/solution/gong-shui-san-xie-liang-chong-mei-ju-zhi-u44s/)：计算斜率等值时为浮点数，可能精度有问题，故能存整数最好存整数，两个整数还可以取得最大公约数，为了当key还可以拼成string）、题150. 逆波兰表达式求值（关键在于对逆波兰表达式的理解和想到栈）、
   8. 贪心：题45. 跳跃游戏 II、
   8. 特殊：题189. 轮转数组（重点是两个原地解法，一个是常用的双旋转，另一个是环状替换，要用gcd求最大公约数）
   
2. 二维数组：

   1. 辅助数据结构：题36. 有效的数独（判重就想set，数字范围小则用数组代替，甚至可以尝试用bitset）
   2. 回溯法：**题37. 解数独**（和题36相似，但这里回溯是核心。还涉及贪心，考虑数独的玩法，从最少可能数值的坐标开始回溯，每次都找有最少可能数值，大大提高效率。不用写代码了，了解思路即可）、题79. 单词搜索（证明了先判断状态可行再进入dfs，会大幅减少复杂度）、题130. 被围绕的区域（关键在于先从边界上的'O'开始，理解题意的重要性）、题200. 岛屿数量（DFS和BFS均可）
   3. 特殊技巧：**48. 旋转图像**（\*\*两种复杂度相同的做法：1. 直观的想法，一圈一圈向里遍历，确定每个点的交换位置，然后做3次swap，关键在于找到坐标，写出坐标，（看高赞的评论）更容易找到规律。2.看官方题解，矩阵旋转可以是上下翻转和对角线翻转的结果。这道题不要想着严谨的数学推导，要靠一点直觉）、**题85**. 最大矩形（\*由矩形的特点，想到把二维矩阵拆解多行列高度的数组，然后利用84题的做法计算。最高赞有一些小优化，掌握核心思想即可）、题151. 翻转字符串里的单词（注意对空格的特殊处理，分成三步（去空格，整体反转，单词反转）则可原地处理，可以用reverse算法来简化写法）
   4. 遍历：题73. 矩阵置零（易错。要先想清楚边界情况。第一行和第一列是特殊情况，需要专门的数字来标记）、题88. 合并两个有序数组（指出自己的优化：尽量优先挪动nums2，nums1能不动就不动，减少不必要的赋值）
   5. 二分查找：题74. 搜索二维矩阵（官解有两种做法，只需能写出第一种。因为两种方法复杂度相当，且第一种不易错，并能出来每行元素个数不相同的情况）
   6. 滑动窗口：题76. 最小覆盖子串（自己的思路是对的。但关键在于简化写法，忽略一些细节，能在更短时间内写完，且不损失过多复杂度，可参见该[答案](https://leetcode-cn.com/problems/minimum-window-substring/solution/leetcode-76-zui-xiao-fu-gai-zi-chuan-cja-lmqz/)）
   7. 动态规划：题120. 三角形最小路径和（考察了**动态规划遍历方向的灵活性**。不要死板的想从上到下从左到右，可依据题意变化，因而能省去时空复杂度。[最好写法](https://leetcode-cn.com/submissions/detail/263462789/)）、**题174. 地下城游戏**（方向是关键。如果选择左上角为初始值，则无法确定初始值，而且无法保证无后效性。从右下角向左上角遍历即可。）

3. 字符串

   1. 递归（回溯）：题17 电话号码的字母组合（全排列，就想递归。也可以用队列，虽然时空复杂度没区别，但是个很好的思路）、题93. 复原 IP 地址（过程中为了便于操作，可以用vector存储最后再转为string）、题131. 分割回文串（看[高赞](https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/)，回溯法先画出树，重点在于**提前动态规划记录所有子串是否是回文串**和时间复杂度）
   2. 辅助数据结构：题20. 有效的括号（栈。简单题可以适当想想剪枝，比如字符总数为奇数，则直接false）、**题30. 串联所有单词的子串**（*判断是否出现，第一反应就是Map，以单词为单位，复杂题可适当用库函数，还要牢牢记清题目条件）

   3. 遍历：

   ​              1. 遍历（特殊题）：**题5 最长回文子串**（1. 中心扩散 2.动态规划 3. *Manacher算法。时间复杂度降到O(n)，不要求具体写，但思想要了解，主旨即只遍历一次，尽可能用遍历过的结果帮后面判断）、**题28 实现 strStr()**（**字符串匹配：1. KMP算法：时间复杂度：O(m+n)，理解前缀后缀，利用已经算过的简化后面的计算，使得只遍历一次，然后重要的是如何构建next数组：本质又是字符串匹配，用前缀匹配后缀。（高赞答案都讲的不清晰，试着自己按照上述理解）2.Sunday算法：了解即可，比KMP时间复杂度差很多，为O(mn)）、题65. 有效数字（最直接不易错的方式为遍历并分情况讨论。[官解](https://leetcode-cn.com/problems/valid-number/solution/you-xiao-shu-zi-by-leetcode-solution-298l/)使用了确定有限状态自动机，了解其用法即可，写法复杂且本质是暴力枚举）、题67. 二进制求和（遍历加翻转最直观）、题171. Excel 表列序号（计算过程中的大数也不能忽略）

   4. 动态规划：**题32 最长有效括号**（\*\*1. 动归，最长子串题常常用到。2. 栈，括号题常用。但这里相对复杂难处理 3. 贪心，太精妙了，左右各一遍堪称牛逼，比前两种省了空间复杂度）、题91. 解码方法（注意可能有解码方案数为0的特殊情况，可以看官解的写法，更加精炼且不易错）、**题132. 分割回文串 II**(求最值第一时间想动态规划。[动归的思维方式](https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/dong-tai-gui-hua-by-liweiwei1419-2/)，先得到正确思路，再优化)、题139. 单词拆分（主要即动态规划。但[官解还提出了简单且很有用的优化思路](https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode-solution/)）、题140. 单词拆分 II（回溯，但有两个优化点，[1.提前动态规划，知道后面的路能不能走](https://leetcode-cn.com/problems/word-break-ii/solution/dong-tai-gui-hua-hui-su-qiu-jie-ju-ti-zhi-python-d/)，[2.记忆化递归，防止重复递归同样字符串](https://leetcode-cn.com/problems/word-break-ii/solution/dan-ci-chai-fen-ii-by-leetcode-solution/)）、题159. 至多包含两个不同字符的最长子串（动态规划和滑动窗口均可。都可以用map辅助。但题目限制两个，[动态规划可以不用map](https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/solution/che-dong-tai-gui-hua-qiu-yi-ge-zan-wu-wu-h715/)，但用map能处理n个的情况。权衡）
   5. 双指针：题125. 验证回文串（考察字符相关Api，如isalnum, tolower）
   5. 特殊：题157、**158**. 用 Read4 读取 N 个字符（关键都在写出简洁代码。[158关键在4个4个挪显然不如一个一个好写。](https://leetcode-cn.com/problems/read-n-characters-given-read4-ii-call-multiple-times/submissions/)）
   5. 滑动窗口：**题187. 重复的DNA序列**（用哈希表。但如果键为子串的话，复杂度要乘上子串长度。**但注意到可选字符少，故可以用几个bit表示一个字符**，子串就可以用整数表示。因位移的便利，取每个子串使用滑动窗口。细心处理位运算）

4. 双字符串或数组：

      1. 遍历：**题43. 字符串相乘**（*摆脱计算乘法的传统思维，把思维简化，只专注于两个位上的数字相乘，就可以把计算部分用int的乘法代替，好写很多）、题161. 相隔为 1 的编辑距离（思路简单，但要注意细节：相同字符串也不符要求；应遍历较长字符串）、题165. 比较版本号（易错：问清题意，比的是数字大小，不是字典序）
      2. 动归（通常状态转移方程是二维或更高维）：**题10和44 字符串匹配**（\*\*1.剑指offer上用递归，但因产生重复子问题，是超时的，尤其在题44. 2.动态规划。此题的首选解法。且解法有细节，如||的使用，可看官方题解）、题64. 最小路径和（用动归的前提即无后效性）、题72. 编辑距离（有多种情况的复杂问题第一想法就是动态规划。关键在确定转移方程，其和状态转移时的选择方式是密切相关的）、**题87. 扰乱字符串**(\*\*看[最高赞](https://leetcode-cn.com/problems/scramble-string/solution/miao-dong-de-qu-jian-xing-dpsi-lu-by-sha-yu-la-jia/)。一个状态可以基于过去的有限状态来决定，可理解为无后效性，那就考虑用dp。复杂题就先不想数学规律，尽量分解为重复问题)、**题97. 交错字符串**（\*关键在于找到动归的状态定义。不要过度理解交错，容易被条件|n - m| <= 1束缚）、题115. 不同的子序列（易忽略大数问题。结果在int范围内不代表过程中不产生大数，可以用unsigned long long通过所有测试用例。优先用二维转移数组写，一维的可以作为优化思路）

5. 链表：

   1. 单链表：
      1. 双指针：题19 删除链表的倒数第 N 个结点、题86. 分隔链表（即partition的单链表版本。由于链表的特性，这里可以保证稳定性）、题142. 环形链表 II（[官解](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/)，要注意到slow走的距离就是环中节点数的倍数，然后不**需要再专门计算环中节点的个数**）、题143. 重排链表（栈可以做。但注意链表通常有节省空间复杂度的断开再重连的方式）、题160. 相交链表
      2. 排序：题23 合并K个升序链表（1.归并排序，注意和数组的不同，这里优先迭代；2. 小顶堆）、**题148. 排序链表**（快排和归并排序皆可。但快排时间复杂度最差为O(n^2)，且递归无法满足常数级时间复杂度。而归并可由底向上且因为链表特性，不需要辅助链表，故为最优解。涉及到大量断开重连，细心）
      3. 遍历：题61. 旋转链表（简单题一定要一次做对）、**题82**、83. 删除排序链表中的重复元素 II（*82易错。注意和面试官沟通，为了简化，没有释放被删除链表节点的内存空间）、题147. 对链表进行插入排序（易错。要移除节点，就一定要记录其前一个节点）
      4. 遍历多指针节点交换：题24 两两交换链表中的节点（注意边界情况）、题25 K 个一组翻转链表（易错，细节，在这种翻转等改变链表结构操作的时候，每当使用一个节点以及其next的时候，一定想清楚它还是不是你本意想用的）、题92. 反转链表 II
   2. 双向链表：
      1. 辅助数据结构：题146. LRU 缓存（能共用的函数最好都提取出来）

6. 树：

      1. 二叉树：
            1. 遍历：
               1. 中序遍历：题94. 二叉树的中序遍历（注意迭代写法，使用栈，避免重复代码。看官解还有一个Morris遍历，使空间复杂度降为常数，了解即可）、题95. 不同的二叉搜索树II（构建二叉树最常用的即先序遍历。复杂问题可以不考虑如返回值传值还是引用的这种细节，优先做完再优化）、**题98. 验证二叉搜索树**（易错。迭代和递归都可以。尽量简化思路。尤其注意迭代方法，利用BST特性，使用中序）、题99. 恢复二叉搜索树（**易错点：未考虑交换两数相邻的情况**。遇到中序遍历，都可以提一下Morris遍历）、**题109.** 有序链表转换二叉搜索树（中序遍历构建二叉树，还是利用递归）、题173. 二叉搜索树迭代器（官解：既可一开始就遍历全部，也可以在取得过程中遍历，显然后者更灵活复杂度更好）
               2. 先序遍历：题100. 相同的树（写法可尽量简化）、题101. 对称二叉树（官解有BFS解法，看看即可）、题105、106. 从前序与中序遍历序列构造二叉树（递归方法细心即可。了解迭代算法即可，看官解）、题108. 将有序数组转换为二叉搜索树（中间节点选偏左或偏右均可，也可随机选择）、题112、113. 路径总和（BFS也可做，了解即可，提供思路，想从子节点回到根节点，可以用hashMap存每个节点和其父亲）、题129. 求根节点到叶节点数字之和（题目本身不难。**是否应考察迭代：先思考递归写法，而递归函数的传值参数和局部变量就代表迭代时栈里要保留的值**）、题144. 二叉树的前序遍历（重点在迭代，Morris也应掌握）
               3. 后序遍历：题104. 二叉树的最大深度（写法可尽量简化。层序也可做）、题110. 平衡二叉树（后序即从底部到顶部）、题124. 二叉树中的最大路径和（\*有时候不考虑后序容易想复杂）、题145. 二叉树的后序遍历（重点在于迭代做法，需要额外空间来记录是一个遍历的节点，或是否遍历过右子节点。Morris也可，了解即可）
               4. 层序遍历：题102、107. 二叉树的层序遍历（107中最后反转结果即可，也可思考list是否比vector更合适）、题103. 二叉树的锯齿形层序遍历（可以用栈、队列、或将题102的结果偶数行翻转）、题111. 二叉树的最小深度（层序和后序都可以。感觉上层序可以提前剪枝，但实际执行效率差不多。后序递归事注意深度的定义）、题199. 二叉树的右视图（BFS最简单。[DFS也可，了解即可](https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/jian-dan-bfsdfs-bi-xu-miao-dong-by-sweetiee/)）
            2. 动态规划：题96. 不同的二叉搜索树（结合上二叉搜索树的构建的动态规划思路。这种有固定状态转移方程的通常有数学的公式，不用记，面试时提一下即可）
            3. 特殊解法：**题114**. 二叉树展开为链表（先序可以做，迭代递归均可，但不是最好。看最高赞解法，还可以不使用额外空间，直接改变树的结构，但每个节点会遍历两遍）、**题117**. 填充每个节点的下一个右侧节点指针 II（比116更具普适性，每一层完全可以视作串联单链表，单链表常用技巧即**哨兵节点**）、题156. 上下翻转二叉树（注意树的特殊结构，采用相应的特殊遍历方法。自顶向下）
            4. 完全二叉树（满二叉树）（这类题往往能优化常规遍历方法的时间或空间复杂度）：**题116**. 填充每个节点的下一个右侧节点指针（常规的层序遍历可解决。但因为多横向的指针存在，就不再需要queue来记录节点）

7. 数字：
   1. 回溯法（递归）：
      1. 题22. 括号生成（1. 回溯法，即DFS，要同时想到栈和BFS，但通常递归写BFS是首选，其他两种方式在这里需要自定义数据结构来记录递归中的参数，故不推荐 2. 动态规划，思路可谓非常惊艳，但空间复杂度不好确定，作为思路拓展）、题51、52. N 皇后（给出所有解法就想到回溯法，自己画画图就能找到遍历过程，关键在于对对角线的处理，既可以往回遍历所有皇后判断是否在同一对角线，也可以向最高赞解那样利用数组记录。52是一样的。两题在记录数组上可以考虑用数字或bitset代替数组或set）、 题60. 排列序列（回溯如果不需要取得所有情况，而是第几个情况，通常可以用数学的方式算的）、题77. 组合（回溯即可。注意剪枝，时间复杂度的计算要注意，可用最终状态个数乘以获得每个状态的复杂度）
   2. 二分查找：
      1. **题29. 两数相除**（**二分查找，类似第50题求幂，本质上是利用答案的数字本质上可以写成二进制，此题看[官方题解](https://leetcode-cn.com/problems/divide-two-integers/solution/liang-shu-xiang-chu-by-leetcode-solution-5hic/)的第二解法即可，另一方面各种防止溢出的细节也要注意）、题50. Pow(x, n)（二分查找的典型。但千万别轻视，细致的考察各种情况。既可以从最低位的1往前，也可以从最高位的1往后。）、题69. Sqrt(x)（官解提供了三种解法。会用二分查找即可。注意为了防止数字溢出，可以用除法代替乘法）
   3. 动归：
      1. 题38. 外观数列（思路简单，但可以考虑用move来提升性能。中间算相等元素区间的时候，一般双指针最清晰）、2、62、63. 不同路径（动归。这种很有规律的题通常有数学公式的快速解法，这题就可以用组合，面试时即便想不出来具体解法，也要表述出记得向该方向探究）、题**89**. 格雷编码（\*复杂问题第一时间想动态规划，只需要考虑相邻两种状态如何变化，本题就变成如何在前一数组基础上增加一个bit，复杂度大大降低）
   4. 遍历：
      1. 题59. 螺旋矩阵 II（还是按照上下左右四个边界进行迭代）、题118、119. 杨辉三角 （118：写法兼顾效率简洁，知道vector的最终大小可以提前resize，避免动态成长。**119：**用公式时要想到避免重复计算，即能得到横向递推）、168. Excel表列名称（十进制转二十六进制。但易错，不是0到26，而是1到26）、题172. 阶乘后的零（分析时间复杂度为对数）
   5. 辅助数据结构：题166. 分数到小数（先想清楚正常情况怎么算。注意细节：负数，大数等。记录余数和其下标，因为无限循环可能只是一部分小数）
   5. 位运算：题190. 颠倒二进制位（普通遍历可做。[官解](https://leetcode-cn.com/problems/reverse-bits/solution/dian-dao-er-jin-zhi-wei-by-leetcode-solu-yhxz/)提供了分治法，复杂度为O(log32),利用了位运算做位移很方便的特性）
   
8. 图：

      1. 无向连通图:
            1. 层序遍历：**题126、127. 单词接龙 II**（DFS和BFS都是备选。但要求最短，往往选BFS，细节很多，思路看[高赞](https://leetcode-cn.com/problems/word-ladder-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-3-3/)，重点在bfs的queue里存路径，就起到了DFS的作用。不需掌握双向BFS。自己又做了[改进](https://leetcode-cn.com/submissions/detail/263910403/)，即能用index就尽量不用string，优化复杂度。双向BFS了解思想即可，永远选较少选择的路走，减少可能岔路）
            1. 深度优先搜索：题133. 克隆图（BFS和DFS都可以）

